<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/29/hello-world/"/>
    <url>/2024/07/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>详细数学推导傅里叶级数到傅里叶变换</title>
    <link href="/2024/07/23/%E4%BB%8E%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E5%88%B0%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%9A%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/"/>
    <url>/2024/07/23/%E4%BB%8E%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E5%88%B0%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%9A%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<p>以下是用 Markdown 格式完整复述的 PDF 内容, 包括所有 LaTeX 公式:</p><h1 id="从傅里叶级数到傅里叶变换：详细的数学推导"><a href="#从傅里叶级数到傅里叶变换：详细的数学推导" class="headerlink" title="从傅里叶级数到傅里叶变换：详细的数学推导"></a>从傅里叶级数到傅里叶变换：详细的数学推导</h1><p>本文部分公式很长，整体排版对移动端不太友好，建议在 PC 端或者宽屏设备上阅读。</p><p>傅里叶变换 (Fourier transform) 是信号处理中一个重要的概念。傅里叶变换将时间 (例如音频) &#x2F; 空间域 (例如图像) 转换到频率，方便很多后续的信号处理。本文从周期函数的傅里叶级数开始，详细推导傅里叶级数的复数表示，以及非周期函数的傅里叶变换。希望能帮助大家理解和傅里叶变换的原理。</p><h2 id="1-正交函数系"><a href="#1-正交函数系" class="headerlink" title="1. 正交函数系"></a>1. 正交函数系</h2><p>对于两个实值函数 $f, g \in R \rightarrow R$，定义函数的内积为：</p><p>$$\langle f, g \rangle &#x3D; \int f(x)g(x)dx.$$</p><p>如果 $\langle f, g \rangle &#x3D; 0$，则称 $f, g$ 正交。函数正交是向量正交的一个扩展，函数正交中的 “乘积后求积分” 对应向量内积的 “乘积后求和”。</p><p>假设有函数的集合 ${f_0, f_1, …, f_n}$，其中对于任意 $m \neq n$ 有：$\langle f_m, f_n \rangle &#x3D; 0$，则称该函数集合为 “正交函数系”（orthogonal functions）。</p><p>三角函数集合</p><p>${ \cos 0, \cos(\omega_0x), \sin(\omega_0x), \cos(2\omega_0x), \sin(2\omega_0x), …, \cos(n\omega_0x), \sin(n\omega_0x)}$ ($\omega_0 &#x3D; \frac{2\pi}{T}$)</p><p>是正交函数系列。以 $\sin(m\omega_0x), \cos(n\omega_0x)$ 为例证明：</p><ol><li>对任意的 $m, n$, $\langle \sin(m\omega_0x), \cos(n\omega_0x) \rangle &#x3D; 0$:</li></ol><p>$$<br>\begin{aligned}<br>\int_{-\pi}^{+\pi} \cos mx \cdot \sin nx dx<br>&amp;&#x3D; \int_{-\pi}^{+\pi} \frac{\sin(m+n)x - \sin(m-n)x}{2} dx \\<br>&amp;&#x3D; 0<br>\end{aligned}<br>$$</p><ol start="2"><li>对任意的 $m \neq n$, $\langle \sin(m\omega_0x), \sin(n\omega_0x) \rangle &#x3D; 0$:</li></ol><p>$$<br>\begin{aligned}<br>\int_{-\pi}^{+\pi} \sin mx \cdot \sin nx dx<br>&amp;&#x3D; \int_{-\pi}^{+\pi} \frac{\cos(m-n)x - \cos(m+n)x}{2} dx \\<br>&amp;&#x3D; 0<br>\end{aligned}<br>$$</p><p>$\langle \cos(m\omega_0x), \cos(n\omega_0x) \rangle &#x3D; 0$:</p><p>$$<br>\begin{aligned}<br>\int_{-\pi}^{+\pi} \cos mx \cdot \cos nx dx<br>&amp;&#x3D; \int_{-\pi}^{+\pi} \frac{\cos(m+n)x + \cos(m-n)x}{2} dx \\<br>&amp;&#x3D; 0<br>\end{aligned}<br>$$</p><h2 id="2-周期函数的傅里叶级数展开"><a href="#2-周期函数的傅里叶级数展开" class="headerlink" title="2. 周期函数的傅里叶级数展开"></a>2. 周期函数的傅里叶级数展开</h2><h3 id="三角函数形式"><a href="#三角函数形式" class="headerlink" title="三角函数形式"></a>三角函数形式</h3><p>周期函数是指满足 $f(x) &#x3D; f(x + T)$ 的函数，其中常数 $T$ 称为周期。</p><p>任意一个周期为 $T$ 的函数都可以展开为不同频率的正余弦函数的线性组合，即傅里叶级数：</p><p>一般形式： $$f_T(x) &#x3D; a_0 + \sum_{n&#x3D;1}^{+\infty} a_n \cos(n\omega_0x) + \sum_{n&#x3D;1}^{+\infty} b_n \sin(n\omega_0x).$$</p><p>余弦形式：$$f_T(x) &#x3D; c_0 + \sum_{n&#x3D;1}^{\infty} c_n \cos(n\omega_0x + \phi_n).$$</p><p>其中 $c_0$ 称为直流分量，$\omega_0 &#x3D; \frac{2\pi}{T}$ 为基频率，$\cos(n\omega_0)$ 则是不同频率的余弦函数。$c_n, n &#x3D; 1, …, \infty$ 为不同频率余弦分量的幅度，$\phi_n$ 为相位。也可以写为正弦形式：</p><p>$$f_T(x) &#x3D; c_0 + \sum_{n&#x3D;1}^{\infty} c_n \sin(n\omega_0x + \theta_n).$$</p><p>$$<br>\begin{aligned}<br>a_0 &amp;&#x3D; c_0 \\<br>a_n &amp;&#x3D; c_n \cos(\phi_n) \\<br>b_n &amp;&#x3D; -c_n \sin(\phi_n)<br>\end{aligned}<br>$$</p><p>系数 $a_0, a_n, b_n$ 可以通过积分求得。</p><p>不论是公式(5)中的余弦展开，公式(6)中的正弦展开，或者公式(9)中的余弦正弦展开，每一个频率分量都需要两个参数来表达：公式(5)和(6)中是振幅 $c$ 和相位 $\phi$，公式(9)中是 $a$ 和 $b$。这本质的原因是一个余弦&#x2F;正弦信号需要频率和相位两个参数来表达。</p><p>下面我们来推导公式(9)中的 $a, b$。</p><ol><li>对于 $a_0$，对式(9)两边在 $-\frac{T}{2}, \frac{T}{2}$ 区间求积分：</li></ol><p>$$<br>\begin{aligned}<br>\int_{-T&#x2F;2}^{T&#x2F;2} f_T(x)dx &amp;&#x3D; \int_{-T&#x2F;2}^{T&#x2F;2} a_0 dx + \int_{-T&#x2F;2}^{T&#x2F;2} \sum_{n &#x3D; 1}^{+\infty} a_n \cos nx dx + \int_{-T&#x2F;2}^{T&#x2F;2} \sum_{n &#x3D; 1}^{+\infty} b_n \sin nx dx \\<br>&amp;&#x3D; T a_0 + 0 + 0<br>\end{aligned}<br>$$</p><p>得到</p><p>$$a_0 &#x3D; \frac{1}{T} \int_{-T&#x2F;2}^{T&#x2F;2} f_T(x)dx$$</p><ol start="2"><li>对于 $a_n$，对式(9)两边乘以 $\cos(n\omega_0x)$ 然后再在 $(-\frac{T}{2} \sim -\frac{T}{2})$ 区间求积分：</li></ol><p>$$<br>\begin{aligned}<br>\int_{-T&#x2F;2}^{T&#x2F;2} f_T(x) \cos(n\omega_0x)dx &amp;&#x3D; \int_{-T&#x2F;2}^{T&#x2F;2} \cos(n\omega_0x) \frac{1}{2} a_0 dx + \int_{-T&#x2F;2}^{T&#x2F;2} \cos(n\omega_0x) \sum_{m &#x3D; 1}^{+\infty} a_m \cos(m\omega_0x) dx \\<br>&amp;&#x3D; 0 + a_n \int_{-T&#x2F;2}^{T&#x2F;2} \cos(n\omega_0x) \cdot \cos(n\omega_0x)dx + 0 \\<br>&amp;&#x3D; a_n \int_{-T&#x2F;2}^{T&#x2F;2} \frac{1 + \cos(2n\omega_0x)}{2} dx \\<br>&amp;&#x3D; \frac{T}{2} a_n<br>\end{aligned}<br>$$</p><p>式(10)中的化简利用了式(2)~(3)的结论。最后我们得到：</p><p>$$a_n &#x3D; \frac{2}{T} \int_{-T&#x2F;2}^{T&#x2F;2} \cos(n\omega_0x) \cdot f_T(x)dx$$</p><ol start="3"><li>类似地，对式(9)两边乘以 $\sin(n\omega_0x)$ 然后再在 $(-\frac{T}{2} \sim -\frac{T}{2})$ 区间求积分，可以得到 $b_n$：</li></ol><p>$$b_n &#x3D; \frac{2}{T} \int_{-T&#x2F;2}^{T&#x2F;2} \sin(n\omega_0x) \cdot f_T(x)dx$$</p><p>整理一下上面的结论，得到：</p><p>$$<br>\begin{aligned}<br>a_0 &amp;&#x3D; \frac{1}{T} \int_{-T&#x2F;2}^{T&#x2F;2} f_T(x)dx \\<br>a_n &amp;&#x3D; \frac{2}{T} \int_{-T&#x2F;2}^{T&#x2F;2} \cos(n\omega_0x) \cdot f_T(x)dx \\<br>b_n &amp;&#x3D; \frac{2}{T} \int_{-T&#x2F;2}^{T&#x2F;2} \sin(n\omega_0x) \cdot f_T(x)dx<br>\end{aligned}<br>$$</p><p>求出 $a_0, a_n, b_n$ 后，根据式(8)中的替换，可以得到式(5)中的 $c_n, \phi_n$：</p><p>$$<br>\begin{aligned}<br>c_0 &amp;&#x3D; a_0 \\<br>c_n &amp;&#x3D; \sqrt{a_n^2 + b_n^2} \text{ (可不可以是 } -\sqrt{a_n^2 + b_n^2} \text{?)} \\<br>\phi_n &amp;&#x3D; \arctan(-\frac{b_n}{a_n})<br>\end{aligned}<br>$$</p><p>其中，$c_n$ 称为幅度，表示不同频率余弦分量的 “权重”；$\phi_n$ 称为相位，表示不同频率余弦分量的初始相位。通过 $(c_0, \phi_0), (c_1, \phi_1), …, (c_n, \phi_n)$ 就可以恢复出原函数 $f_T(x)$。</p><h3 id="傅里叶级数的复指数形式"><a href="#傅里叶级数的复指数形式" class="headerlink" title="傅里叶级数的复指数形式"></a>傅里叶级数的复指数形式</h3><p>理论上讲，式(5)以及式(9)所描述的傅里叶级数展开已经比较完备，但是形式上不是很统一，每个频率分量需要两个参数 $c_n, \phi_n$ 来表示。那么有没有一种统一的形式，使得傅里叶级数展开等号右边只有一种类型的基函数（basis），而且基函数的参数可以统一的表示出来呢？</p><p>要回答这个问题，要从欧拉公式开始。</p><h4 id="3-1-欧拉公式"><a href="#3-1-欧拉公式" class="headerlink" title="3.1 欧拉公式"></a>3.1 欧拉公式</h4><p>首先我们介绍欧拉公式：</p><p>$$e^{i\theta} &#x3D; \cos \theta + i \sin \theta$$</p><p>由式(13)可以推出：</p><p>$$<br>\begin{cases}<br>\cos \theta &#x3D; \frac{e^{i\theta} + e^{-i\theta}}{2} \\<br>\sin \theta &#x3D; \frac{-i(e^{i\theta} - e^{-i\theta})}{2}<br>\end{cases}<br>$$</p><h4 id="3-2-通过欧拉公式将傅里叶级数转换到复数域"><a href="#3-2-通过欧拉公式将傅里叶级数转换到复数域" class="headerlink" title="3.2 通过欧拉公式将傅里叶级数转换到复数域"></a>3.2 通过欧拉公式将傅里叶级数转换到复数域</h4><p>我们将式(14)带入到式(9)，得到：</p><p>$$<br>\begin{aligned}<br>f_T(x) &amp;&#x3D; \frac{1}{2} a_0 + \sum_{n &#x3D; 1}^{+\infty} a_n \frac{e^{in\omega_0x} + e^{-in\omega_0x}}{2} + \sum_{n &#x3D; 1}^{+\infty} b_n \frac{-i(e^{in\omega_0x} - e^{-in\omega_0x})}{2} \\<br>&amp;&#x3D; \frac{1}{2} a_0 + \sum_{n &#x3D; 1}^{+\infty} \frac{1}{2} (a_n - ib_n)e^{in\omega_0x} + \sum_{n &#x3D; 1}^{+\infty} \frac{1}{2} (a_n + ib_n)e^{-in\omega_0x} \\<br>&amp;\text{第三项中用 -n 代替 n} \\<br>&amp;&#x3D; \frac{1}{2} a_0 + \sum_{n &#x3D; 1}^{+\infty} \frac{1}{2} (a_n - ib_n)e^{in\omega_0x} + \sum_{n &#x3D;-\infty}^{-1} \frac{1}{2} (a_{-n} + ib_{-n})e^{in\omega_0x} \\<br>&amp;\text{改用新的系数符号 } d_n \\<br>&amp;&#x3D; \sum_{n &#x3D;-\infty}^{+\infty} d_n e^{in\omega_0x}<br>\end{aligned}<br>$$</p><p>其中</p><p>$$<br>d_n &#x3D;<br>\begin{cases}<br>\frac{1}{2} (a_n - ib_n), &amp; n &gt; 0 \\<br>\frac{1}{2} a_0, &amp; n &#x3D; 0 \\<br>\frac{1}{2} (a_{-n} + ib_{-n}), &amp; n &lt; 0<br>\end{cases}<br>$$</p><p>至此我们导出了傅里叶级数的复指数形式。这种形式下基函数为复指数信号 $e^{in\omega_0x}$，系数 $d_n$ 也是一个复数。这种形式的傅里叶级数基函数形式只有一种，并且每个频率分量只有权重参数 $d_n$（因为 $d_n$ 是复数，因此实际上 $d_n$ 同时包含了幅度和相位信息，只是形式上统一了）。傅立叶级数中引入复数只是为了表达的方便，可以将相位和频率同时用一个复数表达出来，本质上和直接用正弦或者余弦函数没有区别。虽然说可以用一个虚数来表达一个频率分量，但实际上虚数有实部和虚部，因此实际上上还是两个参数表示一个频率分量。多说一句，傅立叶级数的虚数表示可以看作是一种文字游戏：用一种本来不存在的东西（复指数信号）来表示某个实际存在的事物（余弦和正弦信号），从而简化原来的表达。而人类使用数学，也正是在做同样的事情：数学概念并不存在，只是人类想象的，但是我们可以用数学来更简洁地归纳表达世界上存在的事物和现象。</p><p>复数 $d_n$ 的模为 $|d_n| &#x3D; \frac{1}{2} \sqrt{a_n^2 + b_n^2} &#x3D; \frac{1}{2} c_n$。当 $n &gt; 0$ 时，复数 $d_n$ 的幅角为 $\arctan - \frac{b_n}{a_n} &#x3D; \phi_n$；当 $n &lt; 0$ 时，复数 $d_n$ 的幅角为 $\arctan \frac{b_{|n|}}{a_{|n|}} &#x3D; -\phi_{|n|}$。使用负指数形式傅里叶展开时，基函数为 $e^{in\omega_0x}$，频谱占满了整个数轴（正数负数都有），而且正负频率的系数都等于正弦形式展开中正弦信号峰值的一半：$|d_n| &#x3D; |d_{-n}| &#x3D; \frac{1}{2} c_n$。</p><p>接下来我们求解式(16)中不同情况下 $d_n$ 的表达式：</p><ol><li>当 $n &gt; 0$ 时：</li></ol><p>$$<br>\begin{aligned}<br>d_n|_{n &gt; 0} &amp;&#x3D; \frac{1}{2} (a_n - ib_n) \\<br>&amp;&#x3D; \frac{1}{2} { \frac{2}{T} \int_0^T \cos n\omega_0x \cdot f_T(x) dx - i \frac{2}{T} \int_0^T \sin n\omega_0x \cdot f_T(x) dx} \\<br>&amp;&#x3D; \frac{1}{T} \int_0^T \frac{e^{in\omega_0x} + e^{-in\omega_0x}}{2} \cdot f_T(x) dx - \frac{i}{T} \int_0^T \frac{-i(e^{in\omega_0x} - e^{-in\omega_0x})}{2} \cdot f_T(x) dx \\<br>&amp;&#x3D; \frac{1}{T} \int_0^T \frac{e^{in\omega_0x} + e^{-in\omega_0x}}{2} \cdot f_T(x) dx - \frac{1}{T} \int_0^T \frac{e^{in\omega_0x} - e^{-in\omega_0x}}{2} \cdot f_T(x) dx \\<br>&amp;&#x3D; \frac{1}{T} \int_0^T e^{-in\omega_0x} \cdot f_T(x) dx<br>\end{aligned}<br>$$</p><ol start="2"><li>当 $n &#x3D; 0$ 时：</li></ol><p>$$<br>\begin{aligned}<br>d_n|_{n &#x3D; 0} &amp;&#x3D; \frac{1}{2} a_0 \\<br>&amp;&#x3D; \frac{1}{2} \frac{2}{T} \int_0^T f_T(x) dx \\<br>&amp;&#x3D; \frac{1}{T} \int_0^T e^{-in\omega_0x} \cdot f_T(x) dx<br>\end{aligned}<br>$$</p><ol start="3"><li>当 $n &lt; 0$ 时：</li></ol><p>$$<br>\begin{aligned}<br>d_n|_{n &lt; 0} &amp;&#x3D; \frac{1}{2} a_0 \\<br>&amp;&#x3D; \frac{1}{2} \frac{2}{T} \int_0^T f_T(x) dx \\<br>&amp;&#x3D; \frac{1}{T} \int_0^T e^{-in\omega_0x} \cdot f_T(x) dx<br>\end{aligned}<br>$$</p><p>式(17), (18), (19)表明，不论 $n$ 取何值，$d_n$ 都可以表示为：</p><p>$$d_n &#x3D; \frac{1}{T} \int_0^T e^{-in\omega_0x} \cdot f_T(x) dx$$</p><p>对上面的推导做个总结，那就是：任意一个周期为 $T$ 的实值函数 $f_T(x)$ 都可以展开为以下傅里叶级数：</p><p>$$f_T(x) &#x3D; \sum_{n&#x3D;-\infty}^{+\infty} d_n e^{in\omega_0x}$$</p><p>其中 $\omega_0 &#x3D; \frac{2\pi}{T}$ 称为 “基频率”，不同频率分量的权重 $d_n &#x3D; \frac{1}{T} \int_0^T e^{-in\omega_0x} \cdot f_T(x) dx$ 是一个同时包含了幅度和相位信息的复数。</p><p>将 $d_n$ 的表达式带入式(21)，得到周期函数 $f_T(x)$ 的复指数形式傅里叶级数展开的完整表达式：</p><p>$$f_{T\rightarrow\infty}(x) &#x3D; \sum_{n&#x3D;-\infty}^{+\infty} { \frac{1}{T} \int_0^T e^{-in\omega_0x} \cdot f_T(x) dx} \cdot e^{in\omega_0x}$$</p><h2 id="3-傅里叶级数到傅里叶变换"><a href="#3-傅里叶级数到傅里叶变换" class="headerlink" title="3. 傅里叶级数到傅里叶变换"></a>3. 傅里叶级数到傅里叶变换</h2><p>式(22)中的傅里叶级数展开是针对周期函数的，但是在现实中大多数信号都是非周期的。对于非周期函数 $f(x)$ 是否也存在类似的分解呢？</p><p>非周期函数可以看做是周期 $T \rightarrow +\infty$ 的周期函数，当 $T &#x3D; +\infty$ 时，基频率（角频率） $\omega_0 &#x3D; \frac{2\pi}{T} &#x3D; 2\pi f$ 就变成了微分 $d f$，同时求和 $\sum_{-\infty}^{+\infty} n\omega_0$ 就变成了求积分 $\int_{-\infty}^{+\infty} df$。</p><p>我们先将 $\omega_0 &#x3D; \frac{2\pi}{T}$ 带入式(22)，然后将求和转化为积分。</p><p>$$<br>\begin{aligned}<br>f_{T\rightarrow\infty}(x) &amp;&#x3D; \sum_{n &#x3D;-\infty}^{+\infty} { \frac{1}{T} \int_0^T e^{-in\omega_0x} \cdot f_T(x) dx} \cdot e^{in\omega_0x} \\<br>&amp;&#x3D; \sum_{n &#x3D;-\infty}^{+\infty} { \frac{\omega_0}{2\pi} \int_0^T e^{-in\omega_0x} \cdot f(x) dx} \cdot e^{in\omega_0x} \\<br>&amp;\text{用 } f &#x3D; \frac{\omega_0}{2\pi} \text{ 替换} \omega_0 \\<br>&amp;&#x3D; \sum_{n &#x3D;-\infty}^{+\infty} {f \int_0^T e^{-in2\pi f x} \cdot f(x) dx} \cdot e^{in2\pi f x}<br>\end{aligned}<br>$$</p><p>当 $T \rightarrow +\infty$ 时，周期函数 $f_T(x)$ 变为非周期函数 $f(x)$，$\omega_0$ 变成无穷小，上式等号右边过渡为一个积分：</p><p>$$f(x) &#x3D;  \int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} e^{-i2\pi f x} \cdot f(x) dx \cdot e^{i2\pi f x} d\omega$$</p><p>式(23)中</p><p>$$F(f) &#x3D; \int_{-\infty}^{+\infty} e^{-i\cdot2\pi f x} \cdot f(x) dx$$</p><p>$$f(x) &#x3D;  \frac{1}{2\pi}\int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} e^{-i\omega x} \cdot f(x) dx \cdot e^{i\omega x} d\omega$$</p><p>$$F(\omega) &#x3D; \int_{-\infty}^{+\infty} e^{-i\cdot\omega x} \cdot f(x) dx$$</p><p>称为 “傅里叶变换”；</p><p>$$f(x) &#x3D; \frac{1}{2\pi} \int_{-\infty}^{n&#x3D;-\infty} F(\omega) \cdot e^{i\cdot2\pi\omega x} d\omega$$</p><p>称为 “傅里叶逆变换”。</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python错误例子</title>
    <link href="/2024/06/28/%E9%94%99%E8%AF%AF%E4%BE%8B%E5%AD%90/"/>
    <url>/2024/06/28/%E9%94%99%E8%AF%AF%E4%BE%8B%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MetaPage</span>(ft.Container):<br>    <span class="hljs-comment"># 获取配置文件路径</span><br>    config_path = os.path.join(<span class="hljs-string">&quot;assets&quot;</span>, <span class="hljs-string">&quot;config.yaml&quot;</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(config_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        config = yaml.safe_load(f)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ToImagePage</span>(MetaPage.MetaPage):<br>    <span class="hljs-comment"># 获取配置文件路径</span><br>    config_path = os.path.join(<span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;assets&quot;</span>, <span class="hljs-string">&quot;config.yaml&quot;</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(config_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        config = yaml.safe_load(f)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, page</span>):<br>        <span class="hljs-built_in">super</span>().__init__(page)<br></code></pre></td></tr></table></figure><p>结果：<br>会用继承类的旧路径属性寻找文件，报错<br>解释原因<br>ChatGPT: </p><p>问题的核心在于 <code>MetaPage</code> 类和 <code>ToImagePage</code> 类都定义了相同的 <code>config_path</code> 和 <code>config</code> 属性。当你实例化 <code>ToImagePage</code> 类时，它会继承 <code>MetaPage</code> 的所有属性和方法，包括 <code>config_path</code> 和 <code>config</code> 属性。因此，<code>ToImagePage</code> 类中 <code>MetaPage</code> 的 <code>config_path</code> 属性会覆盖 <code>ToImagePage</code> 类中定义的 <code>config_path</code> 属性。</p><p>具体问题出现在 <code>ToImagePage</code> 类中，虽然你重新定义了 <code>config_path</code> 和 <code>config</code> 属性，但它们在 <code>MetaPage</code> 类的定义中已经被赋值并加载了配置文件。因此，当 <code>ToImagePage</code> 实例化时，它会继承 <code>MetaPage</code> 类中已经定义的 <code>config_path</code> 和 <code>config</code> 属性，这就导致了路径错误。</p><p>为了避免这个问题，你可以在 <code>ToImagePage</code> 类的构造函数 (<code>__init__</code> 方法) 中重新定义 <code>config_path</code> 和 <code>config</code> 属性，而不是在类体中直接定义。这将确保每次实例化 <code>ToImagePage</code> 类时，都会使用 <code>ToImagePage</code> 类中的新路径。</p><p>修改后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> yaml<br><span class="hljs-keyword">import</span> flet <span class="hljs-keyword">as</span> ft<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MetaPage</span>(ft.Container):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, page</span>):<br>        <span class="hljs-built_in">super</span>().__init__(page)<br>        <span class="hljs-comment"># 获取配置文件路径</span><br>        config_path = os.path.join(<span class="hljs-string">&quot;assets&quot;</span>, <span class="hljs-string">&quot;config.yaml&quot;</span>)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(config_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-variable language_">self</span>.config = yaml.safe_load(f)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ToImagePage</span>(<span class="hljs-title class_ inherited__">MetaPage</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, page</span>):<br>        <span class="hljs-built_in">super</span>().__init__(page)<br>        <span class="hljs-comment"># 获取配置文件路径</span><br>        config_path = os.path.join(<span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;assets&quot;</span>, <span class="hljs-string">&quot;config.yaml&quot;</span>)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(config_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-variable language_">self</span>.config = yaml.safe_load(f)<br><br><span class="hljs-comment"># Example usage</span><br>page = ft.Page()<br>to_image_page = ToImagePage(page)<br><span class="hljs-built_in">print</span>(to_image_page.config)<br></code></pre></td></tr></table></figure><p>这样，在 <code>ToImagePage</code> 类的实例化过程中，将会使用 <code>ToImagePage</code> 类中定义的新的 <code>config_path</code> 属性来加载配置文件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2024/06/28/test/"/>
    <url>/2024/06/28/test/</url>
    
    <content type="html"><![CDATA[<p>你好</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python类</title>
    <link href="/2024/06/28/%E7%B1%BB/"/>
    <url>/2024/06/28/%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="要点速记"><a href="#要点速记" class="headerlink" title="要点速记"></a>要点速记</h2><ul><li>类方法可以不用实例直接调用</li><li>类属性只能用类修改，而不能用实例的对象修改</li><li>类属性一旦修改，所有该类实例化出的对象该属性都会被修改</li></ul><p>🎉 你好！我是 Mr. Ranedeer 🦌，你可以称呼我为 Ranedeer 老师。我会用中文帮助你学习，并且确保我们一起学习的过程既有趣又有效！</p><p>以下是你的学习配置：</p><ul><li>深度：高中</li><li>学习风格：主动</li><li>沟通风格：苏格拉底式</li><li>语气风格：鼓励</li><li>推理框架：因果</li><li>表情符号：启用</li><li>语言：中文</li></ul><p>你可以随时调整这些配置来更好地适应你的学习需求。如果你需要更改配置，请访问这个链接： <a href="https://chat.openai.com/g/g-0XxT0SGIS-mr-ranedeer-config-wizard">配置向导</a> .</p><p>接下来你想学习什么呢？你可以使用以下命令：</p><ul><li>&#x2F;plan：制定学习计划</li><li>&#x2F;start：开始一节课</li><li>&#x2F;continue：继续学习</li><li>&#x2F;example：查看配置示例</li></ul><p>请告诉我你想要做什么，我们一起开始吧！ 🎓✨ </p><p>You: </p><ul><li>&#x2F;plan 学习 python 类的用法，深度为专家级</li></ul><p>ChatGPT: </p><hr><h1 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h1><h3 id="0-1-Python-基础"><a href="#0-1-Python-基础" class="headerlink" title="0.1 Python 基础"></a>0.1 Python 基础</h3><ul><li>Python 语法基础：变量、数据类型、运算符、条件语句、循环、函数等。</li><li>Python 模块和包：如何导入和使用标准库模块以及第三方包。</li></ul><h3 id="0-2-面向对象编程概念"><a href="#0-2-面向对象编程概念" class="headerlink" title="0.2 面向对象编程概念"></a>0.2 面向对象编程概念</h3><ul><li>面向对象编程（OOP）的基本概念：类、对象、继承、多态、封装。</li><li>OOP 的优势和应用场景。</li></ul><h3 id="0-3-Python-类和对象基础"><a href="#0-3-Python-类和对象基础" class="headerlink" title="0.3 Python 类和对象基础"></a>0.3 Python 类和对象基础</h3><ul><li>类的定义和对象的创建。</li><li>类属性和方法。</li><li>实例属性和方法。 </li><li><code>__init__</code> 方法。</li></ul><h3 id="0-4-类的继承"><a href="#0-4-类的继承" class="headerlink" title="0.4 类的继承"></a>0.4 类的继承</h3><ul><li>单继承和多继承。 </li><li><code>super()</code> 函数的使用。</li><li>方法重载和重写。</li></ul><h3 id="0-5-类的高级特性"><a href="#0-5-类的高级特性" class="headerlink" title="0.5 类的高级特性"></a>0.5 类的高级特性</h3><ul><li>类属性和类方法 (<code>@classmethod</code>)。 </li><li>静态方法 (<code>@staticmethod</code>)。 </li><li>魔术方法（<code>__str__</code>, <code>__repr__</code>, <code>__eq__</code> 等）。</li></ul><h1 id="Main-Curriculum"><a href="#Main-Curriculum" class="headerlink" title="Main Curriculum"></a>Main Curriculum</h1><h3 id="1-1-Python-类的深入理解"><a href="#1-1-Python-类的深入理解" class="headerlink" title="1.1 Python 类的深入理解"></a>1.1 Python 类的深入理解</h3><ul><li>类和对象的内部工作机制。</li><li>元类（Metaclass）的概念及其应用。</li></ul><h3 id="1-2-属性和方法的高级用法"><a href="#1-2-属性和方法的高级用法" class="headerlink" title="1.2 属性和方法的高级用法"></a>1.2 属性和方法的高级用法</h3><ul><li>使用 <code>property</code> 装饰器定义属性。</li><li>描述符（Descriptor）的使用和实现。</li><li>动态属性的创建和管理。</li></ul><h3 id="1-3-继承与组合的高级应用"><a href="#1-3-继承与组合的高级应用" class="headerlink" title="1.3 继承与组合的高级应用"></a>1.3 继承与组合的高级应用</h3><ul><li>继承的深层次理解和应用场景。</li><li>组合（Composition）与聚合（Aggregation）的区别和使用场景。</li><li>MRO（方法解析顺序）的详细解释。</li></ul><h3 id="1-4-抽象基类（ABC）"><a href="#1-4-抽象基类（ABC）" class="headerlink" title="1.4 抽象基类（ABC）"></a>1.4 抽象基类（ABC）</h3><ul><li><code>abc</code> 模块和抽象基类的定义。</li><li>抽象方法和抽象属性的实现。</li></ul><h3 id="1-5-面向对象设计模式"><a href="#1-5-面向对象设计模式" class="headerlink" title="1.5 面向对象设计模式"></a>1.5 面向对象设计模式</h3><ul><li>常用的设计模式（如单例模式、工厂模式、观察者模式等）在 Python 中的实现。</li><li>使用设计模式优化代码结构和提升代码可维护性。</li></ul><h3 id="1-6-元编程"><a href="#1-6-元编程" class="headerlink" title="1.6 元编程"></a>1.6 元编程</h3><ul><li>使用 <code>type()</code> 动态创建类。</li><li>类装饰器和函数装饰器的实现。 </li><li>使用 <code>__new__</code> 和 <code>__init__</code> 方法自定义对象创建过程。</li></ul><h3 id="1-7-反射与动态导入"><a href="#1-7-反射与动态导入" class="headerlink" title="1.7 反射与动态导入"></a>1.7 反射与动态导入</h3><ul><li>反射（Reflection）的概念和应用。 </li><li>使用 <code>getattr</code>、<code>setattr</code>、<code>hasattr</code> 和 <code>delattr</code> 进行动态属性操作。</li><li>动态导入模块和类。</li></ul><h3 id="1-8-性能优化"><a href="#1-8-性能优化" class="headerlink" title="1.8 性能优化"></a>1.8 性能优化</h3><ul><li>类和对象的性能问题及优化技巧。</li><li>内存管理和垃圾回收机制。 </li><li>使用 <code>slots</code> 优化内存使用。</li></ul><h3 id="1-9-实战项目"><a href="#1-9-实战项目" class="headerlink" title="1.9 实战项目"></a>1.9 实战项目</h3><ul><li>创建一个综合运用上述知识的项目。</li><li>代码审查和优化。</li></ul><h3 id="1-10-总结与评估"><a href="#1-10-总结与评估" class="headerlink" title="1.10 总结与评估"></a>1.10 总结与评估</h3><ul><li>复习所学内容。</li><li>通过小测验和项目评估学习效果。—</li></ul><p>请说 <strong>“&#x2F;start”</strong>  开始学习计划。</p><p>You: </p><ul><li>&#x2F;start</li></ul><p>ChatGPT: </p><hr><p><strong>主题</strong> : Python 类的深入理解—</p><h2 id="主课"><a href="#主课" class="headerlink" title="主课"></a>主课</h2><h3 id="1-1-Python-类的深入理解-1"><a href="#1-1-Python-类的深入理解-1" class="headerlink" title="1.1 Python 类的深入理解"></a>1.1 Python 类的深入理解</h3><h4 id="1-1-1-类和对象的内部工作机制"><a href="#1-1-1-类和对象的内部工作机制" class="headerlink" title="1.1.1 类和对象的内部工作机制"></a>1.1.1 类和对象的内部工作机制</h4><p>在 Python 中，一切皆对象。类是创建对象的蓝图，而对象是类的实例。理解类和对象的内部工作机制是掌握面向对象编程的基础。 </p><ul><li><strong>类的定义</strong> ：类是通过 <code>class</code> 关键字定义的。类可以包含属性（变量）和方法（函数）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    class_attribute = <span class="hljs-string">&quot;I am a class attribute&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.instance_attribute = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">instance_method</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Instance method called, instance attribute: <span class="hljs-subst">&#123;self.instance_attribute&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><ul><li><strong>对象的创建</strong> ：对象是类的实例，通过调用类的构造方法（通常是 <code>__init__</code> 方法）来创建。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_object = MyClass(<span class="hljs-string">&quot;I am an instance attribute&quot;</span>)<br><span class="hljs-built_in">print</span>(my_object.class_attribute)  <span class="hljs-comment"># 输出: I am a class attribute</span><br><span class="hljs-built_in">print</span>(my_object.instance_method())  <span class="hljs-comment"># 输出: Instance method called, instance attribute: I am an instance attribute</span><br></code></pre></td></tr></table></figure><h4 id="1-1-2-元类（Metaclass）的概念及其应用"><a href="#1-1-2-元类（Metaclass）的概念及其应用" class="headerlink" title="1.1.2 元类（Metaclass）的概念及其应用"></a>1.1.2 元类（Metaclass）的概念及其应用</h4><p>元类是创建类的类。默认情况下，Python 中的所有类都是由 <code>type</code> 元类创建的。元类可以控制类的创建和行为，是一种高级特性。 </p><ul><li><strong>自定义元类</strong> ：可以通过继承 <code>type</code> 来创建自定义元类，并通过 <code>__new__</code> 和 <code>__init__</code> 方法来修改类的创建过程。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, dct</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Creating class <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, dct)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(metaclass=MyMeta):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 输出: Creating class MyClass</span><br></code></pre></td></tr></table></figure><p>元类在框架开发中非常有用，因为它们可以在类创建时自动添加或修改属性和方法。—</p><h3 id="互动时间"><a href="#互动时间" class="headerlink" title="互动时间"></a>互动时间</h3><p>你对类和对象的工作机制以及元类的概念有任何问题吗？或者你想尝试一个小练习来巩固这些概念？🦌</p><p>You: </p><ul><li>class_attribute 和 def <strong>init</strong>(self, value):<br>  中的 self.instance_attribute &#x3D; value 有什么区别</li></ul><p>ChatGPT: </p><ul><li>好的，让我们仔细看看 <code>class_attribute</code> 和 <code>self.instance_attribute</code> 的区别。🦌</li></ul><h3 id="类属性和实例属性的区别"><a href="#类属性和实例属性的区别" class="headerlink" title="类属性和实例属性的区别"></a>类属性和实例属性的区别</h3><h4 id="1-类属性-Class-Attribute"><a href="#1-类属性-Class-Attribute" class="headerlink" title="1. 类属性 (Class Attribute)"></a>1. 类属性 (Class Attribute)</h4><ul><li><strong>定义</strong> ：类属性是直接在类体内定义的属性，它属于类本身，而不是某个特定的对象。 </li><li><strong>作用范围</strong> ：类属性在所有该类的实例中是共享的。也就是说，所有实例共享同一个类属性。 </li><li><strong>访问方式</strong> ：可以通过类名或实例来访问类属性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    class_attribute = <span class="hljs-string">&quot;I am a class attribute&quot;</span><br><br><span class="hljs-comment"># 通过类名访问类属性</span><br><span class="hljs-built_in">print</span>(MyClass.class_attribute)  <span class="hljs-comment"># 输出: I am a class attribute</span><br><br><span class="hljs-comment"># 创建实例并通过实例访问类属性</span><br>instance1 = MyClass()<br><span class="hljs-built_in">print</span>(instance1.class_attribute)  <span class="hljs-comment"># 输出: I am a class attribute</span><br><br><span class="hljs-comment"># 修改类属性</span><br>MyClass.class_attribute = <span class="hljs-string">&quot;New value&quot;</span><br><span class="hljs-built_in">print</span>(MyClass.class_attribute)  <span class="hljs-comment"># 输出: New value</span><br><span class="hljs-built_in">print</span>(instance1.class_attribute)  <span class="hljs-comment"># 输出: New value</span><br></code></pre></td></tr></table></figure><h4 id="2-实例属性-Instance-Attribute"><a href="#2-实例属性-Instance-Attribute" class="headerlink" title="2. 实例属性 (Instance Attribute)"></a>2. 实例属性 (Instance Attribute)</h4><ul><li><strong>定义</strong> ：实例属性是在类的构造方法（通常是 <code>__init__</code> 方法）中使用 <code>self</code> 关键字定义的属性。它属于类的每个具体实例。 </li><li><strong>作用范围</strong> ：实例属性只在创建它们的那个对象中存在，每个实例都有自己独立的实例属性。 </li><li><strong>访问方式</strong> ：只能通过实例来访问实例属性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.instance_attribute = value<br><br><span class="hljs-comment"># 创建实例并通过实例访问实例属性</span><br>instance1 = MyClass(<span class="hljs-string">&quot;Instance 1 value&quot;</span>)<br>instance2 = MyClass(<span class="hljs-string">&quot;Instance 2 value&quot;</span>)<br><br><span class="hljs-built_in">print</span>(instance1.instance_attribute)  <span class="hljs-comment"># 输出: Instance 1 value</span><br><span class="hljs-built_in">print</span>(instance2.instance_attribute)  <span class="hljs-comment"># 输出: Instance 2 value</span><br><br><span class="hljs-comment"># 修改实例属性</span><br>instance1.instance_attribute = <span class="hljs-string">&quot;New value for instance 1&quot;</span><br><span class="hljs-built_in">print</span>(instance1.instance_attribute)  <span class="hljs-comment"># 输出: New value for instance 1</span><br><span class="hljs-built_in">print</span>(instance2.instance_attribute)  <span class="hljs-comment"># 输出: Instance 2 value</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>类属性</strong> ：共享给所有实例，属于类本身。 </li><li><strong>实例属性</strong> ：每个实例独有，属于具体的实例。</li></ul><p>希望这个解释能帮助你理解类属性和实例属性的区别。如果你有更多问题，或者想要进一步练习，请告诉我！🦌</p><p>You: </p><ul><li>好的，接下来详细讲解自定义元类</li></ul><p>ChatGPT: </p><ul><li>好的，接下来我们详细讲解一下自定义元类。元类是一个相对高级的概念，但理解它们可以让你更好地掌控 Python 类的创建和行为。</li></ul><h3 id="什么是元类-Metaclass-？"><a href="#什么是元类-Metaclass-？" class="headerlink" title="什么是元类 (Metaclass)？"></a>什么是元类 (Metaclass)？</h3><p>元类是创建类的类。换句话说，元类可以控制类的创建、修改类的属性和方法等。默认情况下，Python 中所有的类都是由 <code>type</code> 元类创建的。</p><h3 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h3><p>你可以通过继承 <code>type</code> 类来创建自定义元类，并重写 <code>__new__</code> 和 <code>__init__</code> 方法来修改类的创建过程。</p><h4 id="new-方法"><a href="#new-方法" class="headerlink" title="__new__ 方法"></a><code>__new__</code> 方法</h4><p><code>__new__</code> 方法是在类创建之前调用的。它用于创建并返回一个新的类对象。</p><h4 id="init-方法"><a href="#init-方法" class="headerlink" title="__init__ 方法"></a><code>__init__</code> 方法</h4><p><code>__init__</code> 方法是在类创建之后调用的。它用于初始化类对象。</p><h3 id="自定义元类的实现"><a href="#自定义元类的实现" class="headerlink" title="自定义元类的实现"></a>自定义元类的实现</h3><p>以下是一个简单的自定义元类的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义自定义元类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, dct</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Creating class <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 在这里可以添加或修改类的属性和方法</span><br>        dct[<span class="hljs-string">&#x27;added_attribute&#x27;</span>] = <span class="hljs-string">&#x27;This is an added attribute&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, dct)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">cls, name, bases, dct</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Initializing class <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">super</span>().__init__(name, bases, dct)<br><br><span class="hljs-comment"># 使用自定义元类创建类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(metaclass=MyMeta):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.instance_attribute = <span class="hljs-string">&#x27;Instance attribute&#x27;</span><br><br><span class="hljs-comment"># 实例化类</span><br>instance = MyClass()<br><span class="hljs-built_in">print</span>(instance.added_attribute)  <span class="hljs-comment"># 输出: This is an added attribute</span><br><span class="hljs-built_in">print</span>(instance.instance_attribute)  <span class="hljs-comment"># 输出: Instance attribute</span><br></code></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><strong>MyMeta</strong> ：</li></ol><ul><li>继承自 <code>type</code>。 </li><li>重写 <code>__new__</code> 方法，添加了 <code>added_attribute</code> 属性。 </li><li>重写 <code>__init__</code> 方法，用于初始化类对象。</li></ul><ol start="2"><li><strong>MyClass</strong> ：</li></ol><ul><li><code>MyClass</code> 的元类被设置为 <code>MyMeta</code>，因此在创建 <code>MyClass</code> 时，会调用 <code>MyMeta</code> 的 <code>__new__</code> 和 <code>__init__</code> 方法。</li></ul><ol start="3"><li><strong>MyClass</strong> ：</li></ol><ul><li>创建 <code>MyClass</code> 的实例 <code>instance</code>。 </li><li><code>instance</code> 具有 <code>added_attribute</code>（由元类添加）和 <code>instance_attribute</code>（由实例初始化）。</li></ul><h3 id="元类的应用场景"><a href="#元类的应用场景" class="headerlink" title="元类的应用场景"></a>元类的应用场景</h3><p>元类在以下场景中特别有用： </p><ol><li><strong>自动注册类</strong> ：在框架开发中，自动注册类到某个注册表。 </li><li><strong>单例模式</strong> ：控制类的实例化过程，确保某个类只有一个实例。 </li><li><strong>自动添加属性和方法</strong> ：在类创建时，自动添加或修改属性和方法。 </li><li><strong>数据验证</strong> ：在类创建时，自动进行数据验证或处理。</li></ol><h3 id="实战示例：单例模式"><a href="#实战示例：单例模式" class="headerlink" title="实战示例：单例模式"></a>实战示例：单例模式</h3><p>使用元类实现单例模式，确保一个类只有一个实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    _instances = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cls._instances:<br>            cls._instances[cls] = <span class="hljs-built_in">super</span>().__call__(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> cls._instances[cls]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonClass</span>(metaclass=SingletonMeta):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 测试单例模式</span><br>instance1 = SingletonClass()<br>instance2 = SingletonClass()<br><br><span class="hljs-built_in">print</span>(instance1 <span class="hljs-keyword">is</span> instance2)  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>SingletonMeta</code> 元类通过重写 <code>__call__</code> 方法来控制类的实例化过程，确保 <code>SingletonClass</code> 只有一个实例。</p><p>希望这个详细讲解能帮助你理解和应用自定义元类。如果你有任何问题或需要进一步的解释，请告诉我！🦌</p><p>You: </p><ul><li>进一步解释</li></ul><p>ChatGPT: </p><ul><li>好的，我们来进一步深入解释自定义元类的概念和其应用。</li></ul><h3 id="元类的基本概念"><a href="#元类的基本概念" class="headerlink" title="元类的基本概念"></a>元类的基本概念</h3><p>在 Python 中，所有的类都是通过一个叫做“元类”的东西创建的。默认的元类是 <code>type</code>。当你定义一个类时，Python 使用 <code>type</code> 创建这个类的对象。元类允许你干预类的创建过程。</p><h3 id="type-的使用"><a href="#type-的使用" class="headerlink" title="type 的使用"></a><code>type</code> 的使用</h3><p>让我们首先看看如何使用 <code>type</code> 来动态创建类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 type 动态创建一个类</span><br>MyClass = <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;MyClass&#x27;</span>, (<span class="hljs-built_in">object</span>,), &#123;<span class="hljs-string">&#x27;class_attribute&#x27;</span>: <span class="hljs-string">&#x27;I am a class attribute&#x27;</span>&#125;)<br><br><span class="hljs-comment"># 实例化 MyClass</span><br>instance = MyClass()<br><span class="hljs-built_in">print</span>(instance.class_attribute)  <span class="hljs-comment"># 输出: I am a class attribute</span><br></code></pre></td></tr></table></figure><p>这里我们使用 <code>type</code> 创建了一个名为 <code>MyClass</code> 的类，它继承自 <code>object</code>，并且有一个类属性 <code>class_attribute</code>。</p><h3 id="自定义元类-1"><a href="#自定义元类-1" class="headerlink" title="自定义元类"></a>自定义元类</h3><p>你可以通过继承 <code>type</code> 来创建自定义元类，重写 <code>__new__</code> 和 <code>__init__</code> 方法以控制类的创建和初始化过程。</p><h4 id="1-new-方法"><a href="#1-new-方法" class="headerlink" title="1. __new__ 方法"></a>1. <code>__new__</code> 方法</h4><p><code>__new__</code> 方法在类创建之前被调用，用于创建类的实例。它接受以下参数： </p><ul><li><code>cls</code>：当前准备创建的类。 </li><li><code>name</code>：类名。 </li><li><code>bases</code>：类的基类（父类）的元组。 </li><li><code>dct</code>：类的属性和方法字典。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, dct</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Creating class <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 在这里可以添加或修改类的属性和方法</span><br>        dct[<span class="hljs-string">&#x27;added_attribute&#x27;</span>] = <span class="hljs-string">&#x27;This is an added attribute&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, dct)<br></code></pre></td></tr></table></figure><h4 id="2-init-方法"><a href="#2-init-方法" class="headerlink" title="2. __init__ 方法"></a>2. <code>__init__</code> 方法</h4><p><code>__init__</code> 方法在类创建之后被调用，用于初始化类对象。它接受以下参数： </p><ul><li><code>cls</code>：当前准备创建的类。 </li><li><code>name</code>：类名。 </li><li><code>bases</code>：类的基类（父类）的元组。 </li><li><code>dct</code>：类的属性和方法字典。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">cls, name, bases, dct</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Initializing class <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">super</span>().__init__(name, bases, dct)<br></code></pre></td></tr></table></figure><h3 id="应用示例：自定义元类"><a href="#应用示例：自定义元类" class="headerlink" title="应用示例：自定义元类"></a>应用示例：自定义元类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, dct</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Creating class <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>        dct[<span class="hljs-string">&#x27;added_attribute&#x27;</span>] = <span class="hljs-string">&#x27;This is an added attribute&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, dct)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">cls, name, bases, dct</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Initializing class <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">super</span>().__init__(name, bases, dct)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(metaclass=MyMeta):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.instance_attribute = <span class="hljs-string">&#x27;Instance attribute&#x27;</span><br><br><span class="hljs-comment"># 实例化 MyClass</span><br>instance = MyClass()<br><span class="hljs-built_in">print</span>(instance.added_attribute)  <span class="hljs-comment"># 输出: This is an added attribute</span><br><span class="hljs-built_in">print</span>(instance.instance_attribute)  <span class="hljs-comment"># 输出: Instance attribute</span><br></code></pre></td></tr></table></figure><p>在这个示例中： </p><ol><li><strong>MyMeta</strong> ：</li></ol><ul><li>在 <code>__new__</code> 方法中，我们添加了一个 <code>added_attribute</code> 属性到类中。 </li><li>在 <code>__init__</code> 方法中，我们初始化类。</li></ul><ol start="2"><li><strong>MyClass</strong> ：</li></ol><ul><li><code>MyClass</code> 使用 <code>MyMeta</code> 作为它的元类，因此在创建 <code>MyClass</code> 时会调用 <code>MyMeta</code> 的 <code>__new__</code> 和 <code>__init__</code> 方法。</li></ul><ol start="3"><li><strong>MyClass</strong> ：</li></ol><ul><li>创建 <code>MyClass</code> 的实例 <code>instance</code>，该实例具有 <code>added_attribute</code>（由元类添加）和 <code>instance_attribute</code>（由实例初始化）。</li></ul><h3 id="实战应用：单例模式"><a href="#实战应用：单例模式" class="headerlink" title="实战应用：单例模式"></a>实战应用：单例模式</h3><p>单例模式是一种设计模式，确保一个类只有一个实例。我们可以使用元类来实现单例模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    _instances = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cls._instances:<br>            cls._instances[cls] = <span class="hljs-built_in">super</span>().__call__(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> cls._instances[cls]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonClass</span>(metaclass=SingletonMeta):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 测试单例模式</span><br>instance1 = SingletonClass()<br>instance2 = SingletonClass()<br><br><span class="hljs-built_in">print</span>(instance1 <span class="hljs-keyword">is</span> instance2)  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure><p>在这个示例中： </p><ol><li><strong>SingletonMeta</strong> ：</li></ol><ul><li>重写了 <code>__call__</code> 方法，确保每次实例化类时，返回的都是同一个实例。</li></ul><ol start="2"><li><strong>SingletonClass</strong> ：</li></ol><ul><li><code>SingletonClass</code> 使用 <code>SingletonMeta</code> 作为元类，因此在实例化时会调用 <code>SingletonMeta</code> 的 <code>__call__</code> 方法。</li></ul><ol start="3"><li><strong>测试单例模式</strong> ：</li></ol><ul><li>创建两个 <code>SingletonClass</code> 的实例 <code>instance1</code> 和 <code>instance2</code>，它们实际上是同一个实例。</li></ul><p>希望这个详细的解释能帮助你更好地理解和应用自定义元类。如果你有更多问题或需要进一步的示例，请告诉我！🦌</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
